<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cracked Skin</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000000;
    }

    .poem-line {
      position: fixed;
      left: 50%;
      color: white;
      font-family: 'Courier New', monospace;
      font-size: 24px;
      text-align: center;
      line-height: 1.8;
      opacity: 0;
      transition: opacity 2s ease-in;
      z-index: 10;
      transform: translateX(-50%);
      pointer-events: none;
      white-space: nowrap;
    }

    .poem {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: left;
      max-width: 500px;
      padding: 0 20px;
      font-family: serif;
      font-size: 18px;
      line-height: 1.6;
      color: white;
      opacity: 0;
      transition: opacity 2s ease;
      z-index: 20;
      pointer-events: none;
    }

    .poem.visible {
      pointer-events: auto;
    }

    .hover-word {
      cursor: pointer;
      transition: color 0.3s;
      display: inline-block;
      text-decoration: none;
      color: white;
    }

    .hover-word:hover {
      color: #f5f5dc;
      animation: vibrate 0.15s infinite;
    }

    .hover-word.no-buzz {
      color: white;
    }

    .hover-word.no-buzz:hover {
      color: white;
      animation: none;
    }

    .poet-link {
      cursor: pointer;
      transition: color 0.3s;
      display: inline-block;
      text-decoration: none;
      color: white;
      pointer-events: none;
      opacity: 0.5;
    }

    .poet-link.unlocked {
      pointer-events: auto;
      opacity: 1;
    }

    .poet-link.unlocked:hover {
      color: #f5f5dc;
      animation: vibrate 0.15s infinite;
    }

    @keyframes vibrate {
      0% { transform: translate(0, 0) rotate(0deg); }
      25% { transform: translate(-3px, 3px) rotate(-1deg); }
      50% { transform: translate(3px, -3px) rotate(1deg); }
      75% { transform: translate(-3px, -2px) rotate(-1deg); }
      100% { transform: translate(2px, 2px) rotate(1deg); }
    }
  </style>
</head>
<body>
  <!-- Individual poem lines to fade in one by one -->
  <div class="poem-line" id="line1" style="top: 30%;">You do not have to be good.</div>
  <div class="poem-line" id="line2" style="top: 37%;">You do not have to walk on your knees</div>
  <div class="poem-line" id="line3" style="top: 44%;">for a hundred miles through the desert repenting.</div>
  <div class="poem-line" id="line4" style="top: 51%;">You only have to let the soft animal of your body</div>
  <div class="poem-line" id="line5" style="top: 58%;">love what it loves.</div>
  <div class="poem-line" id="line6" style="top: 65%;">— Mary Oliver</div>

  <div class="poem" id="poemContainer">
    Sick of his own <a href="face.html" target="_self" class="hover-word" data-page="face">face</a>,<br>
    sick of his <a href="skin.html" target="_self" class="hover-word no-buzz" data-page="skin">skin</a>, of the <a href="dark.html" target="_self" class="hover-word" data-page="dark">dark</a>,<br>
    he crawls outside himself<br>
    to <a href="sing.html" target="_self" class="hover-word" data-page="sing">sing –</a>
    <br><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="poet.html" target="_self" class="poet-link" id="poetLink">a better poet than most.</a>
  </div>

  <!-- Audio elements -->
  <audio id="buzzAudio" src="buzzz.mp3" preload="auto" loop></audio>
  <audio id="glassAudio" src="glass.mp3" preload="auto"></audio>

  <script>
    let cells = [];
    let fragments = [];
    let numCellsX = 8;
    let numCellsY = 8;
    let patternPixels = [];
    let poemShown = false;

    let clickCount = 0;
    const maxClicks = 15;
    let cellGroups = [];
    
    const glassAudio = document.getElementById('glassAudio');

    function setup() {
      createCanvas(windowWidth, windowHeight);
      background(0);
      generatePattern();
      divideCellsIntoGroups();
    }

    function generatePattern() {
      cells = [];
      fragments = [];
      patternPixels = [];

      let cellWidth = width / numCellsX;
      let cellHeight = height / numCellsY;

      for (let i = 0; i < numCellsX; i++) {
        for (let j = 0; j < numCellsY; j++) {
          let centerX = i * cellWidth + cellWidth / 2;
          let centerY = j * cellHeight + cellHeight / 2;
          centerX += random(-cellWidth * 0.2, cellWidth * 0.2);
          centerY += random(-cellHeight * 0.2, cellHeight * 0.2);
          cells.push({
            x: centerX,
            y: centerY,
            size: random(cellWidth * 0.4, cellWidth * 0.8),
            active: true,
          });
        }
      }

      // Boundary cells
      for (let i = 0; i <= numCellsX; i++) {
        cells.push({ x: i * cellWidth, y: 0, size: 0, active: false });
        cells.push({ x: i * cellWidth, y: height, size: 0, active: false });
      }
      for (let j = 0; j <= numCellsY; j++) {
        cells.push({ x: 0, y: j * cellHeight, size: 0, active: false });
        cells.push({ x: width, y: j * cellHeight, size: 0, active: false });
      }

      calculatePatternPixels();
    }

    function calculatePatternPixels() {
      for (let x = 0; x < width; x += 3) {
        for (let y = 0; y < height; y += 3) {
          let minDist1 = Infinity;
          let minDist2 = Infinity;
          let closestCell = null;

          for (let cell of cells) {
            let d = dist(x, y, cell.x, cell.y);
            if (d < minDist1) {
              minDist2 = minDist1;
              minDist1 = d;
              closestCell = cell;
            } else if (d < minDist2) {
              minDist2 = d;
            }
          }

          let threshold = 3;
          if (abs(minDist1 - minDist2) < threshold && closestCell) {
            patternPixels.push({
              x: x,
              y: y,
              cell: closestCell,
            });
          }
        }
      }
    }

    function divideCellsIntoGroups() {
      cellGroups = [];
      for (let i = 0; i < maxClicks; i++) cellGroups.push([]);
      let activeCells = cells.filter(c => c.active);
      activeCells.sort(() => random() - 0.5);
      activeCells.forEach((cell, index) => {
        let groupIndex = index % maxClicks;
        cellGroups[groupIndex].push(cell);
      });
    }

    function draw() {
      background(0);
      stroke(255);
      strokeWeight(2);

      for (let pixel of patternPixels) {
        if (pixel.cell.active) {
          strokeWeight(random(1, 2));
          point(pixel.x, pixel.y);

          if (random() < 0.05) {
            let angle = random(TWO_PI);
            let len = random(3, 8);
            line(
              pixel.x,
              pixel.y,
              pixel.x + cos(angle) * len,
              pixel.y + sin(angle) * len
            );
          }
        }
      }

      for (let i = fragments.length - 1; i >= 0; i--) {
        let frag = fragments[i];
        frag.x += frag.vx;
        frag.y += frag.vy;
        frag.vy += 0.3;
        frag.rotation += frag.rotSpeed;
        frag.alpha -= 3;

        push();
        translate(frag.x, frag.y);
        rotate(frag.rotation);
        stroke(255, frag.alpha);
        strokeWeight(1);
        for (let j = 0; j < frag.points.length - 1; j++) {
          line(
            frag.points[j].x,
            frag.points[j].y,
            frag.points[j + 1].x,
            frag.points[j + 1].y
          );
        }
        pop();

        if (frag.alpha <= 0) fragments.splice(i, 1);
      }

      if (fragments.length > 0) loop();
      else noLoop();
    }

    function mousePressed() {
      if (poemShown) return;
      if (clickCount >= maxClicks) return;

      // Play glass sound for first 15 clicks (clickCount 0-14)
      if (clickCount < maxClicks) {
        glassAudio.currentTime = 0;
        glassAudio.play().catch(e => console.log('Audio play error:', e));
      }

      let group = cellGroups[clickCount];
      if (group) {
        group.forEach(clickedCell => {
          let cellPixels = patternPixels.filter(p => p.cell === clickedCell);
          let numFragments = int(random(25, 40));

          for (let i = 0; i < numFragments; i++) {
            let fragPixels = [];
            let startIdx = int(random(cellPixels.length));
            let fragSize = int(random(5, 12));

            for (let j = 0; j < fragSize && startIdx + j < cellPixels.length; j++) {
              let p = cellPixels[startIdx + j];
              fragPixels.push({ x: p.x - clickedCell.x, y: p.y - clickedCell.y });
            }

            if (fragPixels.length > 0) {
              fragments.push({
                x: clickedCell.x,
                y: clickedCell.y,
                vx: random(-5, 5),
                vy: random(-7, -2),
                rotation: 0,
                rotSpeed: random(-0.2, 0.2),
                alpha: 255,
                points: fragPixels,
              });
            }
          }

          clickedCell.active = false;
        });
      }

      clickCount++;

      if (clickCount >= maxClicks && !poemShown) {
        poemShown = true;
        revealPoem();
      }

      loop();
    }

    function revealPoem() {
      const lines = [
        document.getElementById("line1"),
        document.getElementById("line2"),
        document.getElementById("line3"),
        document.getElementById("line4"),
        document.getElementById("line5"),
        document.getElementById("line6")
      ];

      lines.forEach((line, index) => {
        setTimeout(() => {
          line.style.opacity = "1";
        }, 2000 * index);
      });

      // After all lines are shown, wait 3 seconds then fade them out
      setTimeout(() => {
        lines.forEach(line => {
          line.style.opacity = "0";
        });
        
        // After fade out, show the poem with links
        setTimeout(() => {
          const poemContainer = document.getElementById('poemContainer');
          poemContainer.style.opacity = '1';
          poemContainer.classList.add('visible');
        }, 2000);
      }, 2000 * lines.length + 3000);
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      generatePattern();
      divideCellsIntoGroups();
      loop();
    }

    // Link and buzz audio logic
    const visitedPages = new Set(JSON.parse(localStorage.getItem('visitedPages') || '[]'));
    const requiredPages = ['face', 'skin', 'dark', 'sing'];
    const poetLink = document.getElementById('poetLink');
    const buzzAudio = document.getElementById('buzzAudio');

    function checkAllVisited() {
      const allVisited = requiredPages.every(page => visitedPages.has(page));
      if (allVisited) {
        poetLink.classList.add('unlocked');
      }
    }

    // Add buzzing only to links without the no-buzz class
    document.querySelectorAll('.hover-word').forEach(link => {
      if (!link.classList.contains('no-buzz')) {
        link.addEventListener('mouseenter', () => {
          buzzAudio.currentTime = 0;
          buzzAudio.play();
        });
        link.addEventListener('mouseleave', () => {
          buzzAudio.pause();
          buzzAudio.currentTime = 0;
        });
      }

      // Track visited pages
      link.addEventListener('click', function() {
        const page = this.getAttribute('data-page');
        visitedPages.add(page);
        localStorage.setItem('visitedPages', JSON.stringify([...visitedPages]));
        checkAllVisited();
      });
    });

    // Check if all pages have been visited on load
    checkAllVisited();
  </script>
</body>
</html>